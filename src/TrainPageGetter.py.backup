from viewstate import ViewState
from src import config
import requests_html
from datetime import datetime, timedelta
import re
from bs4 import BeautifulSoup

# Updated to use the working mersultrenurilor site
base_url = "https://mersultrenurilor.infofer.ro/ro-RO/Tren/{}"


def get_station_id_by_name(name):
    if name in config.global_station_list:
        return config.global_station_list[name]
    return None


def extract_viewstate(reply):
    state = reply.html.find('#__VIEWSTATE', first=True)

    if not state:
        raise Exception("__VIEWSTATE element not present on webpage")

    state_value = state.attrs['value']

    return state_value


def clean_train_number(train_id):
    """Clean train number for IRIS URL format: extract only the numeric part"""
    import re
    # Extract the first sequence of digits from the train_id
    match = re.search(r'\d+', train_id)
    if match:
        return match.group(0)
    # Fallback: remove spaces and return as-is (legacy behavior)
    return train_id.strip().replace(' ', '')


def get_station_id_by_name(name):
    if name in config.global_station_list:
        return config.global_station_list[name]
    return None


def get_train(train_id):
    """
    Get real train information from IRIS system
    No fallback to demo data - only real data
    """
    return get_real_train_data(train_id)


def get_real_train_data(train_id):
    """
    Get real train data from mersultrenurilor.infofer.ro with live delays
    Uses AJAX to get actual train data with delay information
    """
    import requests  # Use standard requests instead of requests_html
    
    try:
        # Use numeric train ID 
        numeric_train_id = clean_train_number(train_id)
        url = base_url.format(numeric_train_id)
        
        print(f"Fetching train data from mersultrenurilor: {url}")
        
        # Get the page
        reply = session.get(url, timeout=15)
        
        if reply.status_code != 200:
            raise Exception(f"HTTP {reply.status_code} from mersultrenurilor")
        
        # Parse with BeautifulSoup
        soup = BeautifulSoup(reply.content, 'html.parser')
        
        # Extract train stations and delays from the HTML
        stations_data = []
        
        # The HTML structure has station information in text format
        # Pattern: "TIME +DELAY min (întârziere) STATION_NAME km X linia Y"
        # or "LA TIMP STATION_NAME km X linia Y"
        
        page_text = soup.get_text()
        
        # Split into lines and process each one
        lines = page_text.split('\n')
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            
            # Look for station names (they have "km" in the same or nearby line)
            if 'km' in line or (i > 0 and 'km' in lines[i-1]):
                # Try to find station name - it's usually before "km"
                station_match = re.search(r'([A-ZĂÂÎȘȚ][a-zăâîșț\s\-\.]+)\s+km\s+\d+', line)
        
        for link in station_links:
            station_name = link.get_text(strip=True)
            
            # Get the parent element to find times and delays
            parent = link.parent
            while parent and parent.name != 'div':
                parent = parent.parent
            
            if not parent:
                continue
                
            text = parent.get_text(separator=' ', strip=True)
            
            # Extract times (HH:MM format)
            times = re.findall(r'(\d{1,2}:\d{2})', text)
            
            # Extract delay information
            delay_minutes = 0
            
            # Pattern: "+27 min (întârziere)" or "-2 min (mai devreme)" or "la timp"
            delay_match = re.search(r'([+\-]\d+)\s*min', text)
            if delay_match:
                delay_minutes = int(delay_match.group(1))
            elif 'întârziere' in text.lower() and not delay_match:
                # Try to find just a number followed by "min"  
                num_match = re.search(r'(\d+)\s*min', text)
                if num_match:
                    delay_minutes = int(num_match.group(1))
            elif 'mai devreme' in text.lower():
                # Already handled by the +/- pattern above
                pass
            
            station_data = {
                'station_name': station_name,
                'arrival_time': times[0] if len(times) > 0 else None,
                'departure_time': times[1] if len(times) > 1 else None,
                'delay': delay_minutes
            }
            
            stations_data.append(station_data)
        
        if not stations_data:
            raise Exception("No station data found in page")
        
        print(f"Successfully scraped {len(stations_data)} stations for train {numeric_train_id}")
        
        # Find delayed stations
        delayed = [s for s in stations_data if s['delay'] != 0]
        if delayed:
            print(f"  - {len(delayed)} stations with delays")
        
        return {
            'train_number': numeric_train_id,
            'stations_data': stations_data,
            'category': train_id.replace(numeric_train_id, '').strip(),
            'data_source': 'mersultrenurilor_live'
        }
    
    except Exception as e:
        print(f"Error fetching real train data from mersultrenurilor: {e}")
        raise
    """Decode IRIS ViewState data for train information"""
    main_page = state[0][1][1][1][1][3][1][1][1]

    departure_date_raw = main_page[13][0][0][0][7]
    departure_date = re.findall(r"(\d+.\d+.\d+)", departure_date_raw)[0]

    # Collect the info box details
    info_box = main_page[13][1][1][1]

    # Process the latest info field
    latest_info_raw = info_box[13][1][1][0][0][1]
    if latest_info_raw and '[' in latest_info_raw and ']' in latest_info_raw:
        info_station, info_status = re.findall(r"(.*?) \[(.*?)\]", latest_info_raw)[0]
        info_station = info_station.strip()
    else:
        info_station = "Unknown"
        info_status = "Unknown"

    # Process the last update time
    info_time_raw = info_box[15][1][1][0][0][1]
    info_time = None
    if info_time_raw and info_time_raw != '&nbsp;':
        try:
            info_time = datetime.timestamp(datetime.strptime(info_time_raw, '%d.%m.%Y %H:%M'))
        except:
            info_time = None

    # Process the delay field
    delay_raw = info_box[17][1][1][0][0][1]
    delay = None
    if delay_raw != '':
        try:
            delay = int(delay_raw)
        except:
            delay = 0

    # Process the next stop information
    next_station_raw = info_box[23][1][1][0][0][1]
    next_station = next_station_raw.strip() if next_station_raw else "Unknown"

    # Process the next stop time
    next_stop_time_raw = info_box[25][1][1][0][0][1]
    next_stop_time = None
    if next_stop_time_raw and next_stop_time_raw != '&nbsp;':
        try:
            next_stop_time = datetime.timestamp(datetime.strptime(next_stop_time_raw, '%d.%m.%Y %H:%M'))
        except:
            next_stop_time = None

    # Other information
    destination_station = info_box[19][1][1][0][0][1] if info_box[19][1][1][0][0][1] else "Unknown"

    destination_arrival_time_raw = info_box[21][1][1][0][0][1]
    destination_arrival_time = None
    if destination_arrival_time_raw and destination_arrival_time_raw != '&nbsp;':
        try:
            destination_arrival_time = datetime.timestamp(datetime.strptime(destination_arrival_time_raw, '%d.%m.%Y %H:%M'))
        except:
            destination_arrival_time = None

    # Build the data dict
    info_box_data = {
        'rank': info_box[3][1][1][0][0][1] if info_box[3][1][1][0][0][1] else "Unknown",
        'train_id': info_box[5][1][1][0][0][1] if info_box[5][1][1][0][0][1] else "Unknown",
        'operator': info_box[7][1][1][0][0][1] if info_box[7][1][1][0][0][1] else "CFR",
        'route': info_box[9][1][1][0][0][1] if info_box[9][1][1][0][0][1] else "Unknown",
        'status': info_box[11][1][1][0][0][1] if info_box[11][1][1][0][0][1] else "Unknown",
        'latest_information': {
            'station': {
                'name': info_station,
                'id': get_station_id_by_name(info_station),
            },
            'status': info_status,
            'time': int(info_time) if info_time else None,
        },
        'delay': delay,
        'destination': {
            'station': {
                'name': destination_station,
                'id': get_station_id_by_name(destination_station)
            },
            'arrival_time': int(destination_arrival_time) if destination_arrival_time else None
        },
        'next_stop': {
            'station': {
                'name': next_station,
                'id': get_station_id_by_name(next_station),
            },
            'time': int(next_stop_time) if next_stop_time else None,
        },
        'distance': info_box[27][1][1][0][0][1][:-1] if info_box[27][1][1][0][0][1] else "0",
        'trip_duration': info_box[29][1][1][0][0][1][:-1] if info_box[29][1][1][0][0][1] else "0",
        'average_speed': info_box[31][1][1][0][0][1][:-1] if info_box[31][1][1][0][0][1] else "0",
    }

    # Collect the route info box data
    route_data = []
    route_info_box = None

    # Find the route info box
    try:
        route_info_box = main_page[17][1][1][1]
    except (TypeError, IndexError):
        try:
            # The route info box is usually found here on cancelled trains
            route_info_box = main_page[15][1][1][1]
        except (TypeError, IndexError):
            pass

    if route_info_box:
        last_arrival_timestamp = 0
        last_departure_timestamp = 0

        for entry_number in range(1, int(len(route_info_box) / 2)):
            try:
                entry = route_info_box[2 * entry_number - 1][1]

                # Compute the arrival timestamp for this station
                arrival_time_raw = entry[5][0][0][1]
                arrival_timestamp = None

                if arrival_time_raw and arrival_time_raw != '&nbsp;':
                    # We assume the train arrives at this station on the same day it left
                    try:
                        arrival_time_assumption = datetime.strptime(departure_date + ' ' + arrival_time_raw, '%d.%m.%Y %H:%M')

                        if last_arrival_timestamp and last_arrival_timestamp > datetime.timestamp(arrival_time_assumption):
                            # We were wrong in our assumption and the train actually arrives
                            # on the next day at this station, hence we must add one day to the arrival time
                            arrival_time_assumption = arrival_time_assumption + timedelta(days=1)

                        last_arrival_timestamp = datetime.timestamp(arrival_time_assumption)
                        arrival_timestamp = int(last_arrival_timestamp)
                    except:
                        arrival_timestamp = None

                # Compute the departure timestamp for this station
                departure_time_raw = entry[9][0][0][1]
                departure_timestamp = None

                if departure_time_raw and departure_time_raw != '&nbsp;':
                    # We assume the train departs from this station on the same day it left
                    try:
                        departure_time_assumption = datetime.strptime(departure_date + ' ' + departure_time_raw, '%d.%m.%Y %H:%M')

                        if last_departure_timestamp and last_departure_timestamp > datetime.timestamp(departure_time_assumption):
                            # We were wrong in our assumption and the train actually departs
                            # on the next day from this station, hence we must add one day to the departure time
                            departure_time_assumption = departure_time_assumption + timedelta(days=1)

                        last_departure_timestamp = datetime.timestamp(departure_time_assumption)
                        departure_timestamp = int(last_departure_timestamp)
                    except:
                        departure_timestamp = None

                # Decode other raw data
                milepost_raw = entry[1][0][0][1]
                milepost = None
                if milepost_raw:
                    try:
                        milepost = int(milepost_raw)
                    except:
                        milepost = 0

                station = entry[3][0][0][1].strip() if entry[3][0][0][1] else "Unknown"

                stop_duration_raw = entry[7][0][0][1]
                stop_duration = None
                if stop_duration_raw and stop_duration_raw != "&nbsp;":
                    try:
                        stop_duration = int(stop_duration_raw)
                    except:
                        stop_duration = None

                delay_raw = entry[13][0][0][1]
                delay = 0
                if delay_raw and delay_raw != "&nbsp;":
                    try:
                        delay = int(delay_raw)
                    except:
                        delay = 0

                mentions_raw = entry[15][0][0][1]
                mentions = None
                if mentions_raw and mentions_raw != "&nbsp;":
                    mentions = mentions_raw

                entry_data = {
                    'milepost': milepost,
                    'station': {
                        'name': station,
                        'id': get_station_id_by_name(station),
                    },
                    'arrival_time': arrival_timestamp,
                    'stop_duration': stop_duration,
                    'departure_time': departure_timestamp,
                    'is_real_time': entry[11][0][0][1] == 'Real' if entry[11][0][0][1] else False,
                    'delay': delay,
                    'mentions': mentions,
                }

                try:
                    entry_data['mentions_extra'] = entry[15][0][1][1]
                except (TypeError, IndexError):
                    entry_data['mentions_extra'] = None

                route_data.append(entry_data)
            except (IndexError, TypeError) as e:
                print(f"Error parsing route entry {entry_number}: {e}")
                continue

    return {
        'departure_date': departure_date,
        'info_box': info_box_data,
        'route_data': route_data,
    }


def parse_station_row(cells):
    """Parse a table row containing station information"""
    try:
        if len(cells) < 3:
            return None
        
        station_name = cells[0].get_text(strip=True)
        arrival_time = cells[1].get_text(strip=True) if len(cells) > 1 else ""
        departure_time = cells[2].get_text(strip=True) if len(cells) > 2 else ""
        
        if station_name and (arrival_time or departure_time):
            return {
                'station_name': station_name,
                'arrival_time': arrival_time,
                'departure_time': departure_time,
                'delay': 0  # Will be extracted separately if available
            }
    except:
        pass
    
    return None


def parse_station_div(div):
    """Parse a div containing station information"""
    try:
        text = div.get_text(strip=True)
        
        # Look for patterns like "Station Name 14:30 14:32"
        time_pattern = re.search(r'(\d{1,2}:\d{2})', text)
        if time_pattern:
            station_name = text[:time_pattern.start()].strip()
            times = re.findall(r'\d{1,2}:\d{2}', text)
            
            if station_name and times:
                return {
                    'station_name': station_name,
                    'arrival_time': times[0] if len(times) > 0 else "",
                    'departure_time': times[1] if len(times) > 1 else times[0],
                    'delay': 0
                }
    except:
        pass
    
    return None


def parse_json_stations(data, train_id):
    """Parse station data from JSON"""
    stations = []
    
    try:
        for item in data:
            if isinstance(item, dict):
                station_name = item.get('station', item.get('name', item.get('station_name', '')))
                arrival = item.get('arrival', item.get('arrival_time', ''))
                departure = item.get('departure', item.get('departure_time', ''))
                
                if station_name:
                    stations.append({
                        'station_name': station_name,
                        'arrival_time': str(arrival),
                        'departure_time': str(departure),
                        'delay': item.get('delay', 0)
                    })
    except:
        pass
    
    return stations


def format_real_stations(raw_stations, train_id):
    """Format scraped station data into our expected format"""
    formatted = []
    now = datetime.now()
    
    for i, station in enumerate(raw_stations):
        try:
            station_name = station.get('station_name', '')
            arrival_time = station.get('arrival_time', '')
            departure_time = station.get('departure_time', '')
            delay = station.get('delay', 0)
            
            # Convert time strings to timestamps
            arrival_timestamp = None
            departure_timestamp = None
            
            if arrival_time and arrival_time != '--':
                arrival_timestamp = convert_time_to_timestamp(arrival_time, now)
            
            if departure_time and departure_time != '--':
                departure_timestamp = convert_time_to_timestamp(departure_time, now)
            
            formatted.append({
                "station_name": station_name,
                "arrival_timestamp": arrival_timestamp.isoformat() if arrival_timestamp else None,
                "departure_timestamp": departure_timestamp.isoformat() if departure_timestamp else None,
                "delay": int(delay) if delay else 0,
                "platform": station.get('platform', str((i % 6) + 1)),  # Fallback platform
                "is_origin": i == 0,
                "is_destination": i == len(raw_stations) - 1,
                "is_stop": 0 < i < len(raw_stations) - 1
            })
        except Exception as e:
            print(f"Error formatting station {station}: {e}")
            continue
    
    return formatted


def convert_time_to_timestamp(time_str, base_date):
    """Convert time string like '14:30' to datetime"""
    try:
        if ':' in time_str:
            hour, minute = time_str.split(':')
            hour = int(hour)
            minute = int(minute)
            
            # Create datetime for today at this time
            result = base_date.replace(hour=hour, minute=minute, second=0, microsecond=0)
            
            # If the time is earlier than now, assume it's tomorrow
            if result < base_date:
                result += timedelta(days=1)
            
            return result
    except:
        pass
    
    return None


def generate_demo_train_data(train_id):
    """Generate realistic demo data for a train"""
    import random
    
    # Sample route based on train type
    if train_id.upper().startswith('IR'):
        # InterRegio - long distance
        stations_route = [
            "București Nord", "Ploiești Sud", "Sinaia", "Brașov", 
            "Sighișoara", "Mediaș", "Cluj-Napoca"
        ]
    elif train_id.upper().startswith('IC'):
        # InterCity - premium service
        stations_route = [
            "București Nord", "Ploiești Sud", "Brașov", "Cluj-Napoca"
        ]
    elif train_id.upper().startswith('R'):
        # Regional
        stations_route = [
            "București Nord", "Ploiești Sud", "Câmpina", "Sinaia", "Brașov"
        ]
    else:
        # Default route
        stations_route = [
            "București Nord", "Ploiești Sud", "Brașov", "Cluj-Napoca"
        ]
    
    now = datetime.now()
    journey = []
    
    for i, station in enumerate(stations_route):
        arrival_time_dt = now + timedelta(minutes=i * 45 + random.randint(-5, 5)) if i > 0 else None
        departure_time_dt = now + timedelta(minutes=i * 45 + 5 + random.randint(-3, 3)) if i < len(stations_route) - 1 else None
        delay = random.choice([0, 0, 0, 5, 10])  # Most trains on time
        
        journey.append({
            "station_name": station,
            "arrival_time": arrival_time_dt.strftime("%H:%M") if arrival_time_dt else "",
            "departure_time": departure_time_dt.strftime("%H:%M") if departure_time_dt else "",
            "arrival_timestamp": arrival_time_dt.isoformat() if arrival_time_dt else None,
            "departure_timestamp": departure_time_dt.isoformat() if departure_time_dt else None,
            "delay": delay,
            "platform": str(random.randint(1, 6)),
            "is_origin": i == 0,
            "is_destination": i == len(stations_route) - 1,
            "is_stop": 0 < i < len(stations_route) - 1
        })
    
    return journey
